---
eip: 8003
title: Epistemic Context Lattice
description: Standard for verifiable compressed AI context on Ethereum
author: Hyperkit Labs (@Hyperkit-labs)
discussions-to: to be determine (TBD)
status: Draft
type: Standards Track
category: ERC
created: 2026-02-08
requires: 712, 721, 1155, 4337, 8004
---
***

## Abstract

This standard defines a way to store, link, and verify AI context on Ethereum in compressed form.  
The design represents context as hyperdimensional vectors, anchors integrity roots on chain, and models relationships through an on chain graph.  
The goal is to give agents durable memory with cryptographic provenance, while keeping gas and storage costs low.

## Motivation

Large language models use fixed context windows.  
Long conversations, document histories, and cross protocol observations often exceed these limits.  
Agents that help govern protocols, manage portfolios, or coordinate contracts need access to long term knowledge, not only recent messages.  

At the same time, users and protocols need evidence that an agent based a decision on a specific body of information.  
Off chain vector databases or proprietary memory stores do not provide the level of assurance that many DeFi, governance, and oracle use cases require.  

Storing raw text on Ethereum is expensive.  
A million tokens of uncompressed text cost thousands of dollars on mainnet in practice.  
Projects that plan to keep full histories on chain either prune aggressively or fall back to centralized storage.  

Work on HyperKit and similar agent platforms shows how often an agent reads protocol docs, audit reports, and on chain data before building or changing contracts, and this flow benefits from a shared, verifiable memory layer. 

An interoperable context standard gives you three things.  
You gain a common format for compressed context vectors.  
You gain a common graph schema for relationships between those contexts.  
You gain on chain verification hooks that other contracts and off chain systems can trust.

## Specification

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in [RFC 2119](https://www.rfc-editor.org/rfc/rfc2119) and [RFC 8174](https://www.rfc-editor.org/rfc/rfc8174).

### Overview

An Epistemic Context Lattice consists of three logical parts.

1) Context crystals, which hold compressed hyperdimensional vectors that represent text or other input.  
2) An epistemic graph, which links these contexts through typed weighted edges.  
3) Verification utilities, which prove inclusion and relevance for a given query.

This standard defines abstract interfaces for these parts.  
Concrete deployments MAY adapt storage backends, graph structures, or proof systems, as long as they respect the external behavior.

### Data Types

Hypervector

A Hypervector represents one compressed context segment.

Fields:

- data: uint256. Packed bits that represent a vector of fixed dimension.  
- quantization: uint8. Supported values are 1, 2, 4, or 8 bits per dimension.  
- contentHash: bytes32. SHA3 256 of the uncompressed content that fed the encoder.  
- timestamp: uint256. Unix time at crystallization.

ContextNode

A ContextNode ties a Hypervector to graph level metadata.

Fields:

- nodeId: bytes32. Unique identifier.  
- crystal: Hypervector. Compressed representation.  
- nodeType: enum NodeType { ENTITY, CONCEPT, EPISODE, SCHEMA }.  
- parentNodes: bytes32[]. Optional hierarchical parents.  
- merkleRoot: bytes32. Root that commits to the hypervector and any local metadata.  
- surpriseScore: uint256. Optional information gain score in the range 0 to 10_000.

Edge

An Edge describes a directed relation between two contexts.

Fields:

- source: bytes32. Context identifier.  
- target: bytes32. Context identifier.  
- edgeType: enum EdgeType { CAUSAL, TEMPORAL, ASSOCIATIVE, HIERARCHICAL }.  
- weight: uint96. Fixed point weight in the range 0 to 10_000.  
- timestamp: uint256. Creation time.

### Interfaces

This section sketches expected function signatures.  
Exact naming MAY vary, but behavior MUST match.

Context crystal interface, IERC8003Crystal:

- event ContextCrystallized(bytes32 indexed contextId, address indexed agent, bytes32 merkleRoot, uint256 compressionRatio).  
- function crystallize(Hypervector crystal, bytes32[] proof) external returns (bytes32 contextId).  
  Stores a compressed Hypervector, validates an optional Merkle proof against a known anchor, emits ContextCrystallized, and returns a context identifier.  
- function verifyRelevance(bytes32 contextId, uint256 queryVector, uint16 similarityThreshold) external view returns (bool isRelevant, uint256 similarityScore).  
  Compares a stored Hypervector with a query vector and reports a similarity score.  
- function getBlob(bytes32 contextId) external view returns (string blobUri).  
  Returns a content address for the stored vector blob, for example an IPFS or Arweave URI.

Epistemic graph interface, IERC8003Graph:

- function bind(bytes32 sourceContext, bytes32 targetContext, EdgeType edgeType, uint96 weight) external returns (bytes32 edgeId).  
  Creates an edge between two contexts with the given type and weight.  
- function getRelevantSubgraph(uint256 queryVector, uint256 maxDepth, uint96 minEdgeWeight) external view returns (bytes32[] contextIds, Edge[] edges).  
  Returns a set of context identifiers and edges that form a subgraph judged relevant to the query.  
- function deltaUpdate(bytes32 baseContextId, bytes32 deltaHash, bytes compressedDelta) external returns (bytes32 newContextId).  
  Records a new context as a delta relative to a base context, referenced by a delta hash and stored blob.

Verifier interface, IERC8003Verifier:

- function verifyZKProof(bytes proof, bytes32 contextId, uint256 queryVector, uint16 minSimilarity) external view returns (bool valid).  
  Confirms that a zero knowledge proof ties a context and a query to a similarity threshold.  
- function verifyMerkleProof(bytes32 root, bytes32 leaf, bytes32[] proof) external pure returns (bool valid).  
  Confirms that a leaf hash belongs to a Merkle tree with the given root.

### Operations

A typical write operation follows this sequence.

1) An agent or client encodes text or other input into a Hypervector using a deterministic off chain encoder.  
2) The client constructs a Hypervector struct with quantization, contentHash, and timestamp.  
3) The client optionally builds a small Merkle tree over the vector chunks and any extra metadata, and passes the Merkle proof into crystallize.  
4) The crystal contract stores or references the Hypervector, emits ContextCrystallized, and returns a contextId.  
5) The graph contract receives one or more calls that bind this new context to prior contexts through temporal, causal, or other edges.

A typical read operation follows this sequence.

1) A client encodes a query string into a queryVector.  
2) The client calls getRelevantSubgraph with queryVector, a search depth, and a minimum edge weight.  
3) The graph contract computes a traversal or lookup and returns contextIds and edges.  
4) The client fetches the blobs that correspond to these contextIds from off chain storage and decompresses the Hypervectors to text or structured context.  
5) The client MAY call verifyRelevance or verifyZKProof if an on chain or off chain verifier needs a binding between query, contextId, and similarity.

### Chain Specifics

This standard targets Ethereum mainnet and compatible EVM chains.  
Deployments SHOULD place the crystal and verifier contracts on a settlement layer and place the main graph on an L2 to reduce gas for frequent graph updates.  
Deployments MUST document which chain serves as the reference for Merkle roots and which chain holds the canonical graph.

## Rationale

Hypervectors compress large amounts of text or token sequences into fixed length vectors.  
A fixed dimension such as ten thousand bits, combined with low bit quantization, keeps on chain footprints small while preserving enough structure for similarity search and composition.  

The design separates vector content from the chain and references blobs through URIs.  
Chains hold only commitments and minimal metadata.  
This choice reduces gas and leaves room for different off chain codecs and storage systems.

The epistemic graph gives agents and indexers a way to model relations between contexts, rather than treating memory as a flat list.  
Temporal edges let you replay a history.  
Associative and causal edges let you cluster and follow argument structure.  
Weighted edges help tune queries so that older or weaker links have less influence.

The verifier interface provides a hook for projects that run zero knowledge proof systems.  
Such projects want to show that a decision drew from a specific context without exposing full content.  
Standardizing this field and function makes that integration easier across agents and protocols.

The standard references ERC 721 and ERC 1155 because some deployments will choose to wrap contextIds as tokens for ownership, transfer, or access control.  
The reference to ERC 8004 reflects the link between agent identity and agent memory for many agent oriented designs.

## Backwards Compatibility

This proposal adds new contracts and interfaces only.  
The proposal does not change consensus rules or existing ERC behavior.  
Existing applications remain unaffected unless they opt in and integrate these contracts.

## Test Cases

A reference test suite SHOULD cover at least the following cases.

- Crystallization of a Hypervector with a known contentHash, including event emission and contextId stability.  
- Successful and failing calls to verifyMerkleProof with hand built Merkle trees and sample Hypervectors.  
- Edge creation and retrieval through bind and getRelevantSubgraph with simple graphs such as A to B to C.  
- Relevance matching where a queryVector aligned with one stored Hypervector gives a higher similarity score than unrelated vectors.

Test vectors and sample Hypervectors SHOULD live under assets/eip-8003 in the EIPs repository once this reaches Review status.

## Reference Implementation

A reference implementation SHOULD include complete Solidity contracts for IERC8003Crystal, IERC8003Graph, and IERC8003Verifier.  
The reference SHOULD include deployment scripts that target at least one public test network, such as Base Sepolia or Goerli.  
A small client library in TypeScript or Python SHOULD wrap these contracts and expose high level functions such as crystallizeText and queryContext.

A reference implementation for these parts is planned in a public repository and in the EIP assets directory.

## Security Considerations

Context poisoning

Attackers can attempt to store false or malicious context under their own addresses or through compromised agents.  
Contracts that rely on ERC 8003 contexts SHOULD express trust policies, such as only accepting contexts from whitelisted agent identities, or only accepting contexts that carry additional signatures from a multi party process.  
Off chain clients SHOULD combine this with input validation and anomaly detection against known attack patterns.

Prompt and memory injection

Prompt injection attacks often aim to hide malicious instructions in long term memory.  
If agents read from ERC 8003 without filtering and separation, a malicious context entry could influence later reasoning.  
Agent frameworks that use this standard SHOULD keep historical context in a clearly marked section of the prompt and SHOULD treat any imperative statements from context as untrusted data. 
Storage tampering

Storage providers for vector blobs might return forged or corrupted data.  
Clients MUST treat the on chain Merkle roots and contentHash fields as the source of truth.  
Every read of a Hypervector from IPFS or another store SHOULD recompute the hash and verify membership in the Merkle tree before use.

Denial of service

Attackers might spam crystallize or bind calls in order to bloat the graph or exhaust rate limits.  
Deployments SHOULD introduce economic friction for high volume writers, such as small protocol fees, staking requirements for graph updates, or rate limits at the contract level.  
Indexers MAY drop contexts or edges that do not meet quality or relevance thresholds.

Privacy

Hypervectors leak some information about underlying content through similarity and structure.  
Applications that handle private user data SHOULD apply suitable anonymization or aggregation before encoding, or keep sensitive content off shared public graphs.  
Agents that work with secrets SHOULD avoid pushing raw secret derived vectors into public ERC 8003 stores.

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
